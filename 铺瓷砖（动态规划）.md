## 铺瓷砖（动态规划）
力扣上有个题目是 
**[790. 多米诺和托米诺平铺](https://leetcode-cn.com/problems/domino-and-tromino-tiling/)**，
去看了很多的思路和解释，我觉得有两种思路可以去理解这种题目，或者说看到这种题目能够有思路并能正确的解决问题。

1. 1维DP，就是直接找递推公式的思路，其实这个递推公式其实就是高中学数列的时候的数列通项公式，有时候我们可以一下子看出来通项公式，而有的时候我们需要借助数学归纳法来证明，得到递推公式。当然也可以通过迭代递推。数学归纳法则是一种动态规划的思路，最主要的是找到状态转移方程，而递推法更像递归的思路，逐渐分割为子问题。

所以对于这种类型的简单题来说，完全可以根据经验或者简单的数学归纳甚至是找规律的方式，解决问题，而难题，类似于各大OJ，各大比赛出现过的题目，肯定不会出现在面试中咯。

2. 多维DP，看了题解区很多的思路，我发现这种多维的DP对于初学者很友好，从定义DP状态开始，到DP状态转移，最后得出结果的每一步都是有意义的，我觉得掌握这种方式的思路还是很有必要的，这对于解决其他的动态规划问题很有帮助。

当然，这种多维的DP最后优化后就是一维的，甚至是O(1)空间的，就是状态压缩，而多维的方式，是一种有固定思路，固定模式，易掌握，通用的解题思路，在下面的代码中还没有给出这样的思路，有时间再说吧。


### 题目描述
`有一块大小是 2 * n 的墙面，现在需要用不同规格的瓷砖铺满，瓷砖规格如下，请计算一共有多少种铺设的方法。`

PS:由于结果可能很大：返回值需要对 10^9 + 7 取余。
由于Python自带大数，可以不用担心结果溢出，为了保持代码美观，只在return时取余。

### 类型1：A砖：2 * 1型
此处撰写解题思路

### 代码
```python3
# 一维DP状态转移方程：dp[i] = dp[i - 1] + dp[i - 2]
class Solution:
    def numTilings(self, N: int) -> int:
        dp = [0] * (N + 1)
        dp[0], dp[1] = 1, 1
        for i in range(2, N + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[-1] % 1000000007
        

# 状态压缩：
# 只需要记录两个状态
class Solution:
    def numTilings(self, N: int) -> int:
        a, b = 1, 1
        for i in range(2, N + 1):
            a, b = b, b + a
        return b % 1000000007
```



### 类型2：A砖：2 * 1型、B砖：2 * 2型
此处撰写解题思路

### 代码
```python3
# 一维DP状态转移方程：dp[i] = dp[i - 1] + 2 * dp[i - 2]
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        dp = [0] * (N + 1)
        dp[0], dp[1] = 1, 1
        for i in range(2, N + 1):
            dp[i] = dp[i - 1] + 2 * dp[i - 2]
        return dp[-1] % 1000000007
        

# 状态压缩：
# 只需要记录两个状态
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        a, b = 1, 1
        for i in range(2, N + 1):
            a, b = b, b + 2 * a
        return b % 1000000007 
```

### 类型3：A砖：2 * 1型、B砖：2 * 3型
此处撰写解题思路

### 代码
```python3
# 一维DP状态转移方程：dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        dp = [0] * (N + 1)
        dp[0], dp[1], dp[2] = 1, 1, 2
        for i in range(3, N + 1):
            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
        return dp[-1] % 1000000007
        

# 状态压缩：
# 只需要记录三个状态
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        a, b, c = 1, 1, 2
        for i in range(3, N + 1):
            a, b, c = b, c, c + b + a
        return c % 1000000007
```


### 类型4：A砖：2 * 1型、B砖：L型（三块小砖组成）
此处撰写解题思路

### 代码
```python3
# 790. 多米诺和托米诺平铺

# 一维DP状态转移方程：dp[i] = 2 * dp[i - 1] + dp[i - 3]
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        dp = [0] * (N + 1)
        dp[0], dp[1], dp[2] = 1, 1, 2
        for i in range(3, N + 1):
            dp[i] = 2 * dp[i - 1] + dp[i - 3]
        return dp[-1] % 1000000007
        

# 状态压缩：
# 只需要记录三个状态
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        a, b, c = 1, 1, 2
        for i in range(3, N + 1):
            a, b, c = b, c, 2 * c + a
        return c % 1000000007
```

### 其他类型：
* 墙面变化
```
墙面：3 * n、A砖：1 * 1、B砖：2 * 2
方程：dp[i] = dp[i - 1] + 2 * dp[i - 2]
解释：dp[i]可以由两种方式得到，
当右边少一排时，可以全部铺A，这有一种方法，
当右边少两排时，可以铺一个B，两个A，这有两种方法，
所以递推式：dp[i] = dp[i - 1] + 2 * dp[i - 2]
```

```
来源：POJ - 2663
墙面：3 * n、A砖：1 * 2
方程：
n为偶数时：dp[i] = 4 * dp[i - 2] + dp[i - 4]
n为奇数时：0
```

```
来源：zju - acmclub - 1059
墙面：3 * n、A砖：1 * 3、B砖：2 * 3、C砖：3 * 3
方程：
dp[1] = 1、dp[2] = 2、dp[3] = 7
dp[i] = dp[i - 1] + dp[i - 2] + 4 * dp[i - 3] n >= 4
解释：
一般情况（n>4），记铺设3*n墙壁总方案数为dp(n).

1） 如果先铺3*1的墙壁，铺设3*1的方案数为1，还剩下3 *（n-1）的墙壁的总方案数位为dp(n-1)，故这种情况共有有1*dp(n-1)种方案。

2） 如果先铺3*2的墙壁，铺设3*2的方案数为1（因为要去掉与1）中重复的情况），还剩下3 *（n-2）的墙壁的总方案数为dp(n-2)，故这种情况共有有1 * dp(n-2)种方案。

3） 如果先铺3*3的墙壁，铺设3*3的方案数为4（去掉与（1），（2）重复的情况），还剩下3 *（n-3）的墙壁的总分数为dp(n-3)，故这种情况共有有4 * dp(n-3)种方案。

所以可以得出递推式dp(n)=dp(n-1)+dp(n-2)+dp*f(n-3);(n>=4)
```

* 可行性
```
来源：未知，可能是某挑战程序设计竞赛
题目：用 1 * 2 的砖铺 m * n 的地面，地面上有一些障碍物，求是否可以不用切割砖块铺满地面，并计算时间复杂度。
思路：应该可以用dp，也可以用DFS搜索，估计和力扣上的 迷宫、寻宝、地下城 等问题相似，太难啦
```

* 最优性
### 题目：墙面：n * m，瓷砖：正方形瓷砖，目标：最少需要用到多少块方形瓷砖？

[1240. 铺瓷砖](https://leetcode-cn.com/problems/tiling-a-rectangle-with-the-fewest-squares/)

### 代码
```python3
# 1240. 铺瓷砖

```
